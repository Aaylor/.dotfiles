snippet as "Assertion"
assert ${0:false}
endsnippet


snippet af "fun"
(fun ${1:args} -> $0)
endsnippet

snippet ft "function"
function
	| ${1:matching} -> $0
endsnippet

snippet l "let"
let ${1:var} $0
endsnippet

snippet match "match"
match ${1:to_match} with
	| ${2:matching} -> $0
endsnippet

snippet mod "module"
module ${1:Module} = 
struct
	$0
end
endsnippet

snippet tmod "type module"
module type ${1:Module} =
sig
	$0
end
endsnippet

snippet op "open"
open ${1:Module}
endsnippet

snippet v "val"
val ${1:fun} : $0
endsnippet

snippet rec "recursive definition"
let rec ${1:fun} ${2:args} =
	$0
endsnippet

snippet | "guard"
${1:match} -> $0
endsnippet

snippet pr "printf"
Printf.printf "${1:string}" ${2:vals};;
endsnippet

snippet try "try"
try
	$0
with
	$1
endsnippet

snippet type "type record"
type ${1:name} = {${2:var}: ${3:int}$0}
endsnippet

snippet rs "raise" b
raise (${1:Not_found})
endsnippet

snippet matchl "pattern match on a list"
match ${1:list} with
| []      -> ${2:()}
| x :: xs -> ${3:()}
endsnippet

snippet matcho "pattern match on an option type"
match ${1:x} with
| Some(${2:y}) -> ${3:()}
| None -> ${4:()}
endsnippet

snippet cc "commment"
(* ${1:comment} *)
endsnippet


snippet let "let .. in binding"
let ${1:x} = ${2:v} in
${3:e}
endsnippet

snippet lr "let rec"
let rec ${1:f} =
	${2:expr}
endsnippet

snippet if "if"
if ${1:(* condition *)} then
	${2:(* A *)}
else
	${3:(* B *)}
endsnippet

snippet If "If"
if ${1:(* condition *)} then
	${2:(* A *)}
endsnippet

snippet while "while"
while ${1:(* condition *)} do
	${2:(* A *)}
done
endsnippet

snippet for "for"
for ${1:i} = ${2:1} to ${3:10} do
	${4:(* BODY *)}
done
endsnippet

snippet class "class"
class ${1:name} = object
	${2:methods}
end
endsnippet

snippet obj "obj"
object
	${2:methods}
end
endsnippet

snippet Obj "object"
object (self)
	${2:methods}
end
endsnippet

snippet {{ "object functional update"
{< ${1:x} = ${2:y} >}
endsnippet

snippet beg "beg"
begin
	${1:block}
end
endsnippet


snippet oo "odoc"
(**
    ${1:odoc}
 *)
endsnippet

snippet ilm "inline module"
module ${1:modulename} : sig

end = struct

end
endsnippet

snippet qt "inline qtest"
(*$T ${1:name}
	${2:test}
*)
endsnippet


